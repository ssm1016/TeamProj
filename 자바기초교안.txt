[ 자바 개발 환경 구축]

1] JDK(Java Development Tool Kit:자바 개발 도구) 설치- http://www.oracle.com
	종류
	J2SE(Java 2 Standard Edition) - 일반적인 자바 프로그램을 만들 수 있는 기본 패키지                                             
	J2EE(Java 2 Enterprise Edition) - 엔터프라이즈급 프로그램 만들때 사용.EJB/SERVLET등의 기술 사용
	J2ME(Java 2 Micro Edition) - 휴대폰등의 소형 시스템에서 사용할 프로그램을 만들 수 있는 패키지




2] JDK의 주요 폴더 구조 -----

	BIN : JDK에 포함되는 개발 툴의 실행 파일용 디렉토리(컴파일러,인터프리터등)
    LIB : 개발 툴에 의해 사용되는 파일들(라이브러리)
    JRE : 개발도구를 제외하고 실행에 필요한 최소한의 환경만을 제공

	java runtime Environment
        

3]JDK 환경변수 설정

 path설정 : 설치된 JDK의 Bin디렉토리 경로 추가해야 이크립스에서 JRE홈을 읽어 감
 classpath설정 : .(컴파일된 자바의 클래스 파일을 현재 디렉토리에서 찾겠다는 의미)





4]자바의 특징
	1)플랫폼 독립성
	2)객체 지향언어 (자바 c++ c# Python)
	3)멀티 스레드 지원 
	4)자동 메모리 관리
	

*****중요[자바 프로그램 구조]******
	//패키지 선언부
	package 패키지명; //내가 작성한 클래스 나 인터페이스를 관리할 목적

	//import 선언 	
	import java.lang.System;
	//사용할 패키지 import
	//소문자는 패키지 대문자는 클래스명을 의미
	//import java.lang.*; //lang패키지안에 있는 모든 클래스를 의미
		
	//클래스 선언
	public class 클래스명{

		멤버변수;
		메서드;
		//main메서드:프로그램 진입점(Entry Point),
		 하나의 프로그램에는 반드시 하나의 Main메서드가 와야 함
		public static void main(String[] args){

			
			
		}


		
	}

	* 파일명과 클래스명은 일치해야 한다. 즉 클래스명.java로 저장


[자바 프로그램의 실행 과정]

자바는 컴파일+interprete(위에서 순차적으로 실행한다)를 한다.
원시코드(자바파일) ---javac(컴파일:컴퓨터로이해할수있도록해주는방법) --->바이트코드(클래스 파일)--java--->
             JVM의 class loader에 의해 class파일과 외부 lib(클래스)를
                                                                 load한후 verification(코드 검증-악성코드 유무여부등)을 거친후
					Interpreter에 의해 메인 메서드를 한줄씩 실행해 결과를 내보낸다


[프로그램 주석]

- 컴파일러에게 해석하지 않도록 하기위한 구문 
  즉 프로그램의 설명글등에 주로 사용

1] // 한줄 주석

2] /* 여러줄 주석 */

3] /** 도큐먼트화 주석 */
   /* 여러줄 주석과 같으나 
   javadoc에 의해 소스코드에 대한 도울말(html파일)을 생성하는 기능을 함

   각 라인은 하나 이상의 *로 시작하고 주석내에 html을 포함 할 수 있다

   @author :제작자 표시
   @version: 버전 표시
   @return :반환형 기술
   @param:매개변수에 대한 설명
   등등

   /**
   * @author choi cheol hwan
*    @version 1.0
*  이 프로그램은 도큐먼트화 주석을 만들기 위한 테스트 프로그램임
*
*/


import java.lang.*;



public class Hello{

	public static void main(String[] args){

		System.out.println("Hello World");
	}

    /**
	*@param num1 num1은 첫번째 숫자
	*@param num2 num2은 두번째 숫자
	*@return 리턴값은 두 숫자의 합
	*/
	public int getSum(int num1,int num2){

		return num1+num2;
	}

}


   사용법
   dos>mkdir 디렉토리명
   dos>javadoc -d 디렉토리명 자바파일

   ※이클립스에서 UTF-8로 변경후 이크립스로
     API용 문서만들때 한글깨지는 경우

     VM옵션에 아래 내용 추가]

     -locale ko_KR -encoding UTF-8 -charset UTF-8 -docencoding UTF-8 

[변수(variable)]

   1] 변수란:메모리상의 임시 데이터 저장 공간의 이름

   2] 변수의 종류

	:메소드밖에서 선언된 변수
	 멤버변수(전역변수)-------------- instance변수
                 |              선언 예] int num=100; //객체명으로 접근
                 |
		 |------------------------static 변수 
                                선언 예] static int num=100;//클래스명으로 접근

	:메소드안에서 선언된 변수
	 지역변수:메소드안에서만 적용되는 변수

	 *지역변수는 사용시에 반드시 먼저 초기화하고 사용 즉 컴파일 에러 남
	  전역변수는 초기화하지 안해도 디폴트 값으로 초기화 됨

   

  3] 변수의 명명 규칙

      - 영문자와 숫자를 섞어 쓸 수 있으나,숫자로 시작되어선 안된다.
      - 얘약어는 변수로 사용 불가(예]public ,void,main,static등)
      - 한글/한자도 변수명으로 사용가능
	  - 특수문자는 변수로 사용할 수 없다.
	    단, 언더바(_), $는 식별자로 사용 가능
      - 변수명은 명사형으로 지으며,   소문자로 시작. 

      - 잘못된 변수 선언의 예
	   - int 4you : 숫자로 시작 불가
	   - int sharp#4: #라는 특수문자 사용 불가
	   - int public : 예약어는 사용 불가

 4] 변수선언

     접근지정자 modifier 자료형(data type) 변수명;(멤버변수인 경우)
     자료형(data type) 변수명;(지역변수인 경우) ex) int(자료형) a(변수명); int(자료형) b(변수명);


     예] public static int num;

	


[변수의 자료형(Data Type)]
	
중)	1) Primitive Type : 기본 자료형
요)	2) Reference Type : 참조형 
			|		
			|
			+-- 클래스형
			+-- 인터페이스형
			+-- 배열
			+-- String
	                      
   1) Primitive Type : 기본자료형
	   | 
       +  수치형--정수형-------
                       			   byte:1byte(-2^7 ~ 2^7-1:-128 ~ 127)
	   |			   short:2byte(-2^15~2^15-1:-32768~32767)
	   |			   int:4byte(-2^31 ~ 2^31-1:
	                       			-2147483648 ~ 2147483647)
	   |			   long:8byte(-2^63 ~ 2^63-1)
	   |			
  		실수형-------float::4byte
	  		      double:8byte
	   |
	   + 문자형 - char    : '가' 'A' '\u0000' (\u 는 유니코드를 쓸 때 사용한다.)
	   |		   2byte(0~2^16-1:0~ 65535)
	   + 논리형 - boolean : true, false(1bit)

	   *정수형에서는 int형이 디폴트 자료형이고 
	    실수형에서는 double이 기본 자료형임 즉
	  
	    0]소수점 없는 숫자는 int형으로 소수점 있는 숫자는 double형으로 간주

	    1] 수치형에서는 범위를 벗어난 값을 대입하면 에러(int형을 요구)

	      byte b = 128(에러)
	      long l =10000000000;//(에러) 10000000000를 int값으로 인식 고로 뒤에 L(l)을 붙인다

	    2] 정수형에서 int형보다 작은 자료형들의 연산 결과는 int형으로,
	      long형과의 연산 결과는 long 형으로 
              byte a=20; 
	      byte b=10;
	      byte c=a+b(에러)=>형변환 해줘야 함 byte c=(byte)(a+b);

	      long l=10;
	      int num =20;

	      int r=l+num;(에러) =>int r=(int)(l+num); 혹은 long r=l+num;


	      char ch='A';
	      System.out.println(ch);//A출력

	      System.out.println(ch+1);//66출력 왜냐하면 char은 메모리에 저장될때 ansi코드값으로 저장되기때문에
	                               //정수형의 일종.고로 연산결과는 int형이 됨(A의 아스키 코드값이 65임으로
				       //66이 출력.

	      

	    3] long형는 가장 큰 자료형임으로 숫자값을 넣어도 되고 
	      int형 값과 구분하기 위해 숫자뒤에
	      l혹은 L을 붙인다
	      logn l =10;
	      long l2 = 20L;// 혹은 20l;	     

	      
	    4] 실수형은 double이 기본 값임으로 float형에 값을 넣을때는 
	       숫자가 소수점인 경우 반드시 숫자 뒤에 f 나 혹은 F를 붙인다
	       단 소수점이 아닌경우는 상관없음

	     float f= 3.14//(에러)
	     float f2 = 3.14f;//(o);
	     float f3 =3;//(o)

	     5] 실수형에서는 같은 float형끼리의 연산은 float형이고 
	       double형과 float형 연산시에는 결과는 double형임
	     float f=10;
	     float f1=10.3f;
	     float f2=f+f1;//(o)

	     double d=f+f1;//(o)

	     ---------------

	     float f=10;
	     double f1=10.3;

	     float f2= f+f1;//(에러)
	     double f2 = f+f1;//(o)

	     6] 실수형과 정수형의 연산 결과는 더 큰 자료형을 따른다 
	        float형과 int형은 같은 4byte이지만
	        실수형이 더 큰 자료형으로 간주한다

	      float f =10;
	      int num =20;

	      int r= f+num;//(에러)
	      float r=f+num;//(o)

[상수(Conastant)]
  

    public static final int A=10;

	-절대로 변하지 않은 불변의 값
	-상수로 정의시에는 키워드 final 을 변수명 앞에 붙인다
	-상수는 보통 대문자로 정의하고 public static을 함께 쓴다
	-상수는 프로그램 중간에 값을 변경하면 에러 난다
	-상수는 반드시 초기화를 하여야 한다.

	예]
	public static final int MY_CONSTANT=10;

        int num;
	public void Hap(){

		num=20;
		MY_CONSTANT=20;//에러

		System.out.println(num+MY_CONSTANT);

	}

[형변환(Type Casting)]
    
	-묵시적 형변환: 작은 범위의 데이터를 큰 범위의 할당하는 경우와 같이
			값의 변화가 발생하지 않는 변환
			

	-강제적 형변환(캐스팅):
	  큰 범위의 데이터를 작은 범위의 할당하는 경우는 
	  값의 변화가 일어날 수
                       있기때문에 변환 하고자하는 
		       변수명앞에 (데이타형)을
                       지정한다		
		       즉 캐스팅 연산자() 이용하여야 한다

		       *큰 범위의 데이터를 작은 범위의 할당하는 
		       경우 강제적 변환을 하지 않으면 에러

	예)
	double d =12.34;
	int i = 1234;
	//double > int :묵시적 형식 변환
	d=i;
	System.out.println(d);//1234.0
	d=12.34;
	i=(int)d;
	System.out.println(i);//12
	
[이스케이프 문자]
-출력시 사용되는 escape문자

	\n: 줄 바꿈,그리고 커서는 줄바꿈한 줄의 처음에 위치
	\t: 탭키만큼 들여쓰기,즉 스크린 커서를 탭키만 큼 옮김
	\r: 캐리지리턴(동일한 줄의 맨 앞으로 커서 옮김,줄바꿈은 안됨) 
	    콘솔에서 테스트 해야함,이클립스에서는 \r과 \n이 동일한 결과를 내보냄
	    단,java로 텍스트파일 생성시(자바IO이용) \r\n으로 줄바꿈 처리해야
	    메모장이나 editplus에서 똑같이 줄바꿈 처리가 잘된다.
	    (왜냐하면 키보드의 엔터키는 \r\n 임으로)
	
	    콘솔에서 테스트시)
	
	    System.out.print("Hello Java\rXXX") 
	    System.out.print("YY");=>XXXYY Java로 출력됨
	    System.out.println();
	    System.out.print("Hello Java\nXXX") 
	    System.out.print("YY");=> Hello Java   //줄바꿈
	                              XXXYY로 출력됨


	*키보드의 엔터키는 \r\n임 
	\': 작은 따옴표 문자 자체 표현
	\": 큰따옴표 자체 문자 표현
	\\:백슬래시(\)기호 자체 *이클립스에서는 \로 보이는 경우 window->preference->general->color and fonts->basic->text fonts->굴림체로
	

[연산자 종류]

1] 단항 연산자: 항이 하나인 연산자
	ㄱ)증감연산자 : ++  --
	ㄴ)부호연산자 : +  -
	ㄷ)비트별 NOT연산자(1의 보수) : ~	 
	ㄹ)논리 부정 연산자 : !

2] 산술 연산자 : * / % + -    

3] 쉬프트연산자 : << , >>     

	-두항이 반드시 정수여야한다
	 정수 <<  비트수: 왼쪽으로 비트수만큼 이동하고 오른쪽에
				     남은 비트는 0으로 채운다

	 정수 >> 비트수 : 오른쪽으로 비트수만큼 이동하고
		                      왼쪽에 남은 비트는 부호비트로 채운다(1:음수,0:양수)

4] 비교 연산자 : <  <=  >  >=  != 

5] 비트 연산자 : &(and)  ^(xor)  |(or)  ~(not)
		- 두항이 정수여야 한다.
		- 두 항이 정수값일때 비트 연산자로 사용됨
		  그렇지 않고 두항이 비교식일때는 논리연산자로 사용됨
		예]   3> 4 & 5 < 4 : &는 논리연산자
		        4 & 5 : & 는 비트 연산자
		

		  - & : 비트 연산시 둘다 1일때만 1 아니면 0
		  - | : 둘중의 하나라도 1이면 1
		  - ^ : 서로 배타적일때 즉 서로 값이 다를때는 1 같으면 0
		  - ~ : 1이면 0 ,0이면 1
		
		예]	4: 0000 0100			
			5: 0000 0101
			-------------------
		   4&5  0000 0100 =>4
		   4|5   0000 0101 =>5
		   4^5   0000 0001 =>1


6] 논리 연산자 : &&   ||  !, &, |, ^
7] 조건 연산자(삼항 연산자) : ? ;
8] 할당 연산자 : =  +=  *=  /=  -=등 (축약표현)


[연산자 우선 순위]

:()는 모든 연산자에 우선한다

:연산자 우선 순위는 산술 > 비교 > 논리 연산자 순이다.

같은 연산자 내에서도 우선 순위가 존재한다.
또한 연산순위가 같은 항목들이 순서 대로 나열되어 있다면 왼쪽에서 오른쪽으로 연산자의 우선 순위를 결정한다. 

:산술 연산자 내의 우선 순위 

*(곱하기)/(나누기)/(몫)%(나머지)(3) > +(더하기)-(빼기)(4)



:비교 연산내의 우선순위 

비교 연산자는 모두 우선순위가 같다 고로 여러 개의 비교 연산자가 사용되엇을 경우

왼쪽에서 오른쪽으로 우선순위가 결정된다.

:논리 연산내의 우선 순위 

NOT(1) > AND(2) > OR,XOR(3)


[제어문] 프로그램의 흐름을 제어하는 명령문

-조건문(분기문)(if문 : 범위 -값이 연속적
	         switch문 : 값이 이산적일때)
		if문은 조건식이 필요하다 조건식은 true,false를 말함.
	
	-반복문(for문(구간반복) for(초기식;반복조건;증감식){
				반복조건이참일때 실행할문장;
				}
	반복횟수가 정해져있을때 for문을 작성

	while문(조건반복) 
	
	do~while문(실행반복))
	-기타(continue문,break문)


[Wrapper 클래스]

기본형의 값을 참조형으로 사용해야 하는경우 사용되는 클래스를 의미하며 
기본형의 값을 참조형으로 포장한다는 의미로 WARAPPER 클래스라 부름
JDK1.4이전 버전에서는 엄격하게 구분 되었으나 JDK5.0 이상 버전에서는
auto-boxing및 auto-unboxing지원으로 쉽게 변환 가능.

--------------------------------------------------------------
    기본자료형(Primitive Type)	|  참조형(Reference Type)
--------------------------------------------------------------
	byte			|   Byte
	short			|   Short
	int			|   Integer
	long			|   Long
	float			|   Float
	double			|   Double
	char			|   Character
	boolean			|   Boolean
--------------------------------------------------------------

소스 예1]
	int a=10;
	int b=20;
	//1.4 이전버전의 코딩방식
	Integer aObj = new Integer(a);
	Integer bObj = new Integer(b);

	//int sum = aObj+bObj;//1.4 이전버전에서는 에러
	int sum =aObj.intValue()+bObj.intValue();//1.4이전 코딩 방식

	System.out.println(sum);
	System.out.println(bObj.toString());//

	//5.0이상 코딩 방식(오토박싱 및 언박싱 지원)
	//래퍼클래스와 기본자료형 사이에서 나온 개념
	//JDK5.0이후에 나온 개념
	//기본자료형->레퍼런스형(오토박싱)
	//레퍼런스형->기본자료형(오토 언박싱)


	Integer cObj =a;//auto-boxing
	System.out.println(cObj);
	int d= cObj;//unboxing
	System.out.println(d);


*기본형을 String(참조형)으로 사용하기

int a=10;
String str= String.valueOf(a);

*String형을 기본형으로

String str="100";
int a=Integer.parseInt(str);


[배열]
	-변수: 하나의 이름으로 하나의 데이터 형식을 하나만 저장하는 그룻 

		String name="홍길동";
		int age =21;
		
	-배열: 하나의 이름으로 하나의 데이터 형식을 여러개 저장 가능한 공간 
	즉 동종의 테이타를 저장하는 자료구조

		
        	int[] i = {10,20,30};

	-1]배열 선언
	
	데이타형[] 배열명; 혹은 데이타형 배열명[];

         int[] j;  int j[];
	//int[][] data; //2차원 배열 선언시 []로 차수 구분

	-2]배열 메모리 할당 
	배열명 = new 데이타형[배열크기]

	 j = new int[3];
	data = new int[2][3]; //2행 3열의 2차원 배열

	-3]배열 초기화

        j[0]=10;
	j[1]=20;
	j[2]=30;


	data[0][0]=10;
	data[0][1]=20;
	data[0][2]=30;
	data[1][0]=40;
	data[1][1]=50;
	data[1][2]=60;

      


	
	*배열의 선언과 메모리 할당 동시에
	int[] j = new int[3];
	int[][] data = new int[2][3];


	

	*배열의 선언및 메모리할당 및 초기화 동시에 - 
	

	int[] j = new int[]{100,90,80};//

	
	int[][] data = new int[][] {{10,20,30},{40,50,60}};

	혹은
	int[] j = {100,90,80};
	int[][] data={{10,20,30},{40,50,60}};


	*배열의 크기는 배열명.length
	*배열은 초기화 하지 않으면
	(단,먼저 반드시 메모리 할당해야함) 
	디폴트 값으로 초기화 된다(지역변수라도)
	


[객체지향 프로그래밍(OOP:Object Oriented Programming]


 1]OOP란? 
        인간의 현실세계를 정보화 시스템으로 반영하기 위해 
	모든 개념(사물,현상,사건)등을
	객체화 시켜 프로그램에 반영 하는 것

 2]객체(Object) : 유무형의 물체,현상,사건등을 의미.
          

 3]object의 특징: 객체는 속성과 행위를 갖는다.
	    	속성은 변수로 행위는 함수로 구성한다 
		이를 객체 모델링 이라 함
		객체지향 프로그래밍에서는 변수를 멤버변수(속성)로 함수를 메소드라 부른다


 4]OOP 프로그래밍의  순서
	1.프로그램에 필요한 객체를 뽑아냄
	2.객체 모델링 : 객체의 속성과 행위 뽑아냄
	3.클래스 구성 : 행동(메소드) 변수 (속성)
	4.객체 생성 및 사용


5]OOP의 주요 특징
*영어기억*
        1. 추상화(Abstraction)
        2. 캡슐화
        3. 다형성
        4. 상속성

[추상화(Abstraction)] 

 어떤 물체(object)에서 주된 특징을 부각시켜 표현하고,
 나머지 부분은 과감하게 생략하는 것
 OOP에서 사용되는 추상화도 이와 비슷하다.
 한 물체를 대표하는 속성(명사)과 행위(동사)를 
 추출해내는 것을 프로그래밍에서는 추상화 라고 한다.



	[1 클래스의 정의]


		클래스란: 인간 세계의 객체를 추상화 한것
		즉 객체의 설계도라 할 수 있다

		-클래스도 하나의 자료구조다.즉 데이타 타입이다

		선언]

		*클래스의 멤버로는 멤버변수와 메서드등을 갖는다

         (public이 접근지정자)접근지정자 [modifier] class 클래스명{//클래스명은 대문자로 시작

			접근지정자 자료형 멤버변수명;
			
			접근지정자 반환형 메서드

		}

	[2  객체 생성 및 멤버접근방법]


		클래스명 인스턴스변수 = new 생성자(); new하면 실제 메모리가 생긴다

		*클래스 멤버 접근 방법

		인스턴스형멤버(instance)에는 인스턴스변수.멤버로 접근
		정적멤버(static)에는 클래스명.멤버로 접근

		

		 -멤버변수는 크게 정적멤버 변수와 인스턴스형 멤버변수로 나눈다
		 -멤버메소드도 정적메소드 와 인스턴스형 메소드로 나눈다.
		  
		 -멤버변수나 멤버 메소드 앞에 static이라는 modifier가 붙으면
		   정적 멤버 즉 정적 멤버변수이거나 정적 메소드이다.
		  
		   예] int age;//인스턴스형 멤버변수
		       static int age;//정적 멤버변수
		       
		       public void method(){};//인스턴스형 메소드
		       public static void method(){};//정적 메소드
		       
		       단,class앞에는 static을 붙일 수 없다
		 
		  ※ 정적멤버(변수 혹은 메소드)의 메모리는 JVM에서 
		     클래스를 로드할 시점에 생기고
		     인스턴스형 멤버는 JVM에서 인터프리터 할때 메모리가 생성된다.
		     
		  ※ 클래스의 멤버에 접근시 접근 방법
			 
			 1]인스턴스형 멤버 : 인스턴스형변수.멤버
			 
			   클래스명 인스턴스형변수 = new 생성자();
			   인스턴스형변수.멤버;
			  
			 2]정적 멤버 :클래스명.멤버
		  



	[3 접근 지정자(access modifier)]
	
	접근지정자: 클래스와 클래스간에 access법위를 지정하는 기능

	[접근지정자를 붙일 수 잇는곳]:
	1]접근지정자 [modifier] class 클래스명
	2]접근지정자 final 자료형 멤버상수=초기값:접근지정자와 modifier는 순서는 상관없다
	  final 접근지정자 자료형 멤버상수=초기값
	3]접근지정자 [modifier] 자료형 멤버변수;
	4]접근지정자 [modifier] 반환타입 메소드명;
	  단, class 앞에 붙일 수 있는 접근지정자는 public과 생략형만 붙일 수 있다.



	접근지정자 범위 : private < 생략형 < protected < public

	private: 자기 클래스내에서만 접근 가능
	생략형(디폴트접근 지정자,패키지접근지정자):
	 같은 패키지 안에서만 접근 가능
	protected: 같은 패키지는 물론 다른 패키지일지라도 상속관계가 있으면 접근 가능
	public:어디서나 접근 가능



	추상화 예] 은행통장(객체)를 자바 프로그램에서 추상화(class) 해보자

	   1.통장이 공통적으로 갖고 있는 속성을 뽑아내자
	     속성:예금주,잔고,계좌번호....
	          =>has a 관계를 가져 야함

	   2.통장이 지닌 행위나 동작 혹은 기능등을 뽑아내자

	     행위:입금하다 출금하다..

	    
            =>모델링한 객체를 자바 프로그램에서 class(추상화)화 시킨다
	      class는 객체가 아니라 현실 셰계의 객체를 추상화 한 것이다
	      즉 클래스는 객체의 설계도이다

	    class Account{
	        
		String name;//예금주
		String acoountNo;//계좌번호
		int balance;//잔고
		


		public int withDraw(int amount){ //출금하다
			
			if(balance < amount) return 0;
			else {
				balance-=amount;
				return b;

			}

			

		}
		
		public void deposit(int amount){//입금하다

			balance+=amount;

		}

		public void getAccountInfo(){

			System.out.println("예금주:"+name);
			System.out.println("계좌번호:"+accountNo);
			System.out.println("예금잔고:"+balance);

		}
		
	    }  
               	        


[은닉화(Encapsulation)]

	- 멤버변수를 캡슐화하되 멤버변수에 접근할 때는 
	  메소드로 접근하도록 한다.

	- 캡슐화 방법
		1. 멤버 변수 앞에 private 접근 지정자를 붙인다.
		   예] private int balance;

		2. 멤버 변수에 값을 할당하고 값을 꺼내올 수 있는 
		   메소드를 만든다.
		   2.1 setter메소드.
			      메소드의 접근 지정자는 public 반환타입은 없고, 매개변수를 받아들이도록 한다
			      setter메소드의 역할:
						 매개변수의 값을 멤버변수에 할당하는 일.
						public void setBalnace(int money){
							balance=money;
						}
			
		   2.2 getter메소드
		             메소드들은 반환타입이 있되 매개변수는 받아들이지 않는다.
			     getter메소드의 역할:
						멤버변수 설정된 값을 반환해주는 일

						public int getBalance(){
								return balnace;
						}


[this와 super]

	  1] this 키워드
          -자기 자신의 인스턴스형 멤버에 접근할때 사용하는  키워드         
	  -정적 메소드 안에서 사용할 수 없다.
	  
	  예]
		private int balance;//멤버변수

		public void setBalnace(int balance){//매개변수(지역변수)
			//balance=balance; //매개변수=매개변수 
			this.balabce=balance;//멤버변수 = 지역변수
		}


	  2] super 키워드
	    - 부모클래스의 멤버에 접근할때 사용(단,private는 접근 불가)	   
	    - 정적 메소드 안에서 사용할 수 없다.
				  
			

[다형성(Polymorphism)]

	*메소드와 관련된 개념

	1] 오버로딩(Overloading)-중복정의
	    하나의 클래스 안에서 적용되는 개념으로 같은 
	            이름의 메서드를 여러개 정의 할 수 있다
	    - 메소드명이 동일해야 한다.
	    - 매개변수의 데이터 타입이 다르거나
	    - 매개변수의 갯수가 다르거나 
	       매개변수의 타입이 다른 경우 순서가 다른 경우도 오버로딩이다	    
	    - 메소드의 반환타입은 상관이 없다.

		



	2] 오버라이딩(Overriding)-재정의
	    상속시에 적용되는개념 즉 부모로부터 상속 받은 메소드를 
	    재정의해서 사용하는 것
	    - 메소드명이 동일해야 한다.
	    - 메소드의 매개변수 갯수, 데이터타입이  같아야 한다.
	    - 메소드의 반환타입도 같아야 한다.
	    - 부모 메서드의 접근 지정자가 
	       public이거나 protected인 경우에만 오버라이딩이 된다.

	    - 부모 메서드가 default 지정자나 private지정자를 
	       가진 메서드를 오버라이딩 한경우
	       자식 고유의 메서드로 처리된다(오버라이딩 한 것이 아님)	
	       //단,default접근 지정자는 다른 패키지에서는
	//접근이 안됨으로 부모와 자식이 다른 패키지일 경우에만
	       //오버라이딩 한것이 아님.
	      //같은 패키지일 경우는 오버라이딩에 해당

	    - Exception의 경우 부모 클래스의 메소드와 동일하거나 
	      더 구체적인 Exception을
	      발생시켜야 한다.



[생성자]

	1]생성자란?
	   : 객체가 생성될 때(인스턴스화) 최초로 실행되는  메소드를 의미.
	 
	2]생성자 특징
	
		- 생성자 이름은 클래스명과 동일해야 한다
		- 반환타입을 가져선 안된다.
		- 생성자의 접근지정자로는 주로 public속성

	3]생성자의 역할
		
		- 멤버 변수를 초기화 하는 일
		- 생성자를 구현하지 않았을 경우 컴파일러는 
		default생성자를 제공해줌
                - 생성자를 하나라도 구현했다면, 그 때는 컴파일러가 
		default생성자를 제공 해주지 않는다.
		- 생성자를 다양하게 오버로딩 함으로써 다양한 초기값을 
		부여할 수 있다.


[this() 와 super()]

	1] this()
		- 생성자 안에서 자기 자신의 생성자를 호출하는 메소드
		- 한 클래스 안에 여러 개의 생성자가 오버로딩된 형태로 존재하고, 
		  그 기능이 유사할 때
		  this()라는 키워드를 이용해서 자기 자신의 다른 생성자를 
		  호출할 수 있다.

		- 단, this()는 생성자 안에서만 호출해야 한다.
		- this()를 호출할 때는 반드시 생성자의 첫번째 문장이어야 한다.

                - 생성자 안에서 this()와 super()를 함께 쓸 수 없다.

	2] super()

		- 자식 클래스를 인스턴스화 할때 컴파일러가 
		   기본적으로 자식의 생성자안에서 자동으로  
		    부모의 기본 생성자인 super()를 호출한다
		- 부모의 생성자중 오버로딩 된 인자 생성자를 
		   명시적으로 호출할때 사용
		-  super()역시 생성자 안에서만 호출
		- 생성자의 맨 첫줄에 위치 해야 한다.

		- 부모에 인자 생성자를 만들때는 
		부모에 기본생성자를 만드는게 유리하다. 왜냐하면 자식 클래스의 객체 생성시(인스턴스화)
		  자식 클래스의 생성자에서 기본적으로 부모의 기본 생성자(super())를 호출하기 때문에
		  부모에 기본 생성자가 없는 경우 에러남
		
	소스예]

	class Parent
	{
	
		String name;
		//기본 생성자가 없음으로 컴파일러가 자동으로 기본 생성자를 생성해 주지 않음
		public Parent(String name){
			this.name=name;
		}
	
	}
	class Child extends Parent
	{
		public Child(){
			 //아래 문장 생략시 부모의 기본 생성자인 super()호출 함으로 에러
			 super("홍길동");
		}
	}

[상속성(Inheritance)]

	- 추상화한 클래스(부모)에 새로운 기능이나 속성을 추가하여 
	   새로운 클래스(자식)로 만드는 것을 의미.
	- 상속 개념을 적용함으로써 개발시간 단축, 재사용성 등으로 
	   OOP 장점을 살릴 수 있다.
	- 상속 관계는 부모와 자식간에 "자식 is a 부모"라는 is a 관계가
	  성립할때 맺을 수 있다
	- 자바에서 상속을 받을 때는 extends 란 키워드를 사용.
	- 자바는 단일 상속 개념이므로 extends 로 상속 받을 수 있는 
	  클래스는 단 하나뿐이다.



 	[상속과 관련된 또 하나의 개념 heterogeneous(이질화)  
	      <---->homogeneou(배열):같은 타입의 데이타 저장]

	-부모타입 참조변수=new 자식의객체생성 
	<=부모와 자식의 상속관계일 때 가능
	 단,자식타입 참조변수 = new 부모타입(X)

  	-부모타입으로 변수 선언을 하고 자식의 객체를 생성했을 경우
	  그 참조변수로 참조할 수 있는 범위는 제한이 있다.

  	  1. 부모로부터 물려받은 변수, 메소드-접근가능
	  2. 자식이 오버라이딩한 메소드가 있을 경우, 
	    그 오버라이딩한 메소드를 우선 호출한다.-접근가능
	  3. 자식이 가지는 고유한 변수 메소드-접근 불가능
	  4. 자식이 오버로딩한 메소드 -접근 불가능
	  
  	-접근 못하는 경우 자식클래스 타입으로 형변환 하면 접근 가능하다
     		((자식타입)참조변수).접근못하는메소드나 변수


	-부모타입의 배열 선언후 자식객체 및 부모 객체 모두 저장 가능 
	단 이때도
	자식 객체를 할당 하더라도 부모타입의 배열에 자식 객체를 
	할당 하기때문에
	참조 범위는 위의 내용과 같다. 
	고로 배열이지만 heterogeneou컬렉션이 됨.


	
[ static block]

	-static block 혹은 static Initializer라고도 함
	-main보다 먼저 수행  됨
	-static변수의 초기화에 사용.
	-static{}
	예]

	class 클래스명{

		static int num ;//static변수
		String name; 

		static{//static 블락

		//이 블락안에는 static멤버로 선언된 멤버에만 접근 가능
			
			
			
			num =10;//[o]
			//name="홍길동";//[x]

			staticPrint();//[o]

			//nonStaticPrint();//[x]
			
			int sum= num*100;
			System.out.println("num은 "+num+",sum="+sum);
		
		}
		
		public void nonStaticPrint(){

			System.out.println("인스턴스 메서드");
		}


		public static void staticPrint(){

			System.out.println("정적 메서드");
		}


		public static void main(String args[]){

			//객체 생성 안하고 있음
		}

	}



[패키지(package)]

	- 유사한 기능을 가진 클래스와 인터페이스를 묶어 관리하도록 하며 
	   개발이 끝난 후 jar파일로 묶어 배포한다.
	- 패키지 선언은 최상단에 위치해야 한다. import 문 보다도 먼저 와야 한다
	- 패키지명은 소문자로 주로 준다
	- 패키지선언에서 패키지안에 있는 클래스에 접근시에는 .으로 접근한다 
	   즉 패키지명.클래스(예:java.lang.System)
	- 파일 관리시의 디렉토리 개념과 같다. 같은 종류의 파일들을 
	  디렉토리로 묶어서 
	   관리하는것과 같은 개념.
	- java파일에서 패키지를 선언했다는 것은 class파일이 
	  그 패키지(디렉토리)안에 있어야 한다는 의미


	
	[패키지가 선언된 파일의 컴파일 및 실행 방법]

		1. 패키지 컴파일 이용 안하고 사용하기(-d옵션 사용 안함)

			step1) 미리 package를 위한 디렉토리를 패키지명과 같게 만든다(예]디렉토리명:nooption)
			step2) java파일에서 아래와 같이 package선언후 step1)디렉토리에 저장	      
				

				package nooption;//컴파일된 class파일이 pack에 있다는 의미

				public class Nooption{


					public static void main(String[] args){

							System.out.println("-d옵션 사용안하기");

					}


				}
				
				컴파일: dos>javac nooption\자바파일명.java  혹은 dos>javac ./nooption/자바파일명.java

				실행 :  dos>java nooption.자바파일명


		2. 패키지 컴파일 이용하기
			-d옵션을 사용해서 컴파일 하면 package선언문에 선언된 디렉토리가 자동 생성 됨
               
                        step1)java파일에서 아래와 같이 패키지 선언후 루트디렉토리에 저장
	      
				package option;
	   
				컴파일:dos>javac -d  .  자바파일명.java       =>option디렉토리가 자동으로 생성 됨(.은 현재 디렉토리의 의미 

				실행:dos> java option.자바파일명

				

	[*Access Modifier [접근지정자]의 접근 범위]

		
	-----------------------------------------------------------------------------
	Modifiers|Same Class    |Same Package    |자식 Class| Different Package
	------------------------------------------------------------------------------
	public    | yes		    | yes		      | yes	       | yes									   
	------------------------------------------------------------------------------
	protected| yes		    | yes		      | yes	       | 상속관계여야만 접근 가능
	------------------------------------------------------------------------------
	default	 | yes	   | yes		      |  No (다른 패키지인경우)        | No
	---------------------------------------------------------------
	private	 | yes	   | No		      |  No         | No
	---------------------------------------------------------------
	※접근 지정자중 protected, private 은 클래스 앞에 못쓴다.


	[패키지 배포]

	-패키지를 jar로 압축하여 배포한다. 압축시 패키지의 루트 패키지를 압축한다
	-jar 사용법: jar cvf jar파일명(xxx.jar) 루트패키지(디렉토리)
                     dos>jar cvf my.jar my

	-jar 생성후 jdk버전\jre\lib\ext디렉토리에 jar파일을 복사한다
	 
	 jvm이 외부 라이브러니(클래스파일)는 ext디렉토리에서 찾는다.

     
    이클립스 사용시]
		/*
		 * jar파일로 묶는 방법]
		 * 
		 * 루트 패키지 선택 -> 마우스 우클릭 -> export
		 * ->java의 Jar file선택 -> 필요한 패키지 체크후 finish
		 * 
		 * jar파일 가져다 쓰는 방법1]
		 * 
		 * Poject선택후 마우스 우클릭->Build Path->Configure Build Path
		 * ->Add External Jars클릭후 jar로 묶은 파일 선택
		 * 
		 * jar파일 가져다 쓰는 방법2]
		 * 
		 * jdk가 설치된 디렉토리 즉
		 * jdk1.7.0_40\jre\lib\ext 폴더에 jar파일을 넣어 놓으면
		 * 이클립스가 끌어옴.
		 * 
		 */


	[※자주 사용하는 패키지]

		-java.io : 파일을 다루는 클래스와 입,출력을 담당하는 스트림들을 포함
		-java.lang : 자바의 기본패키지로서 System클래스등 아주 기본적이고 자주 사용하게될 클래스(String,Wrapper,Math,Thread등)
		-java.util : 자료구조 콜렉션, 
		 날짜/시간 클래스등 유틸리티성 클래스들을 포함(
		      Random클래스,ArrayList,LiinkedList,Stack,Calendar등)
		-java.awt : 자바에서 윈도우 어플리케이션을 제작할수 있는 클래스들을 포함.(Button,Color,Graphics등)
		-javax.swing : 확장된 윈도우 어플리케이션을 제작할수 있는 클래스들을 포함 (주로 Awt클래스에 J가 붙음)
		-java.net : 네트워크 프로그램을 제작할수 있는 소켓등을 포함
		-java.sql : 데이터베이스와 연동시 필요한 클래스들을 포함

[컬렉션 클래스]

	- Collection인터페이스로 부터 구현된 클래스
	- 데이타를 효율적으로 사용하기 위한 하나의 자료구조
	- 객체(클래스)만 저장 할 수 있다.
	- get()메서드 혹은 Iterator,Enumeration인터페이스의 메서드릉 이용해서
          객체를 꺼내 올 수 있다. 
	- 메모리 기반의 작은 데이타 베이스 역할을 한다(입력.삭제.검색등)

	- collection인터페이스의 주요 메서드

		int size():컬렉션에 저장된 객체의 개수 리턴
		boolean isEmpty();객체가 비었으면 true,아니면 false반환
		boolean add(Object obj): 객체 추가.성공시 true
		boolean remove(Object obj):객체 삭제.성공시 true
		boolean removeAll(Collection col)저장된 객체 전체 삭제
		boolean contains(Object obj):해당 객체가 있으면 true.
		Iterator iterator():Iterator인터페이스 반환
			
	

	컬렉션의 계층 구조]중요 외우기


				              Collection
					       |
					       |
           		+----------------------------+-------               
       			|                               |                         
		       Set (interface)                   List                            Map                       
			|                                |                              	   |
		     HashSet                      ArrayList,Vector            HashMap,HashTable         
	

중요 외우기
	-Set계열은 데이터 저장시 중복을 허용하지 않고 순서없이 입력된다.
	-List계열은 데이터 중복을 허용하고 순서있게 저장된다. 
	-Map계열은 키와 값의 쌍으로 저장되고
   	 인덱스가 아닌 키값으로 검색해서 검색 속도가 빠르다 

	-------------------+-------------------------------------------+----------------------------------------------------
			   |	      Set계열                          |                 List계열                                                                  
	-------------------+-------------------------------------------+-----------------------------------------------------
			   |       HashSet                             |             ArrayList                              
	-------------------+-------------------------------------------+--------------------------------------------------
	객체 생성          | 	HashSet<E> set =new HashSet<E>()       |        ArrayList<E> list= new ArrayList<E>()            
	-------------------+-------------------------------------------+---------------------------------------------------	
	객체요소의 개수    |          size()			       |		  size() 
	-------------------+-------------------------------------------+--------------------------------------------------                       
	객체 저장          |          add()                            |                  add()  
             ------------------+-------------------------------------------+-------------------------------------------------                             
      	객체 꺼내오기      |     Iterator iterator()                   |         Iterator  iterator(),get(int index) 
	-------------------+-------------------------------------------+-----------------------------------------------------
	객체 삭제          |     remove(Object o)                      |         remove(Object o),remove(int index)
            -------------------+-------------------------------------------+-----------------------------------------------------                                                                                                        
   	  

	-------------------+------------------------------------------------------+-------------------------------------------------
			   |	     List계열                                     |                  Map계열                                                                  
	-------------------+------------------------------------------------------+------------------------------------------------
			   |	      Vector                                      |                 Hashtable/HashMap                        
	-------------------+------------------------------------------------------+--------------------------------------------------
	객체 생성          |   Vector<E> vec =new Vector<E>()                     |           Hashtable<E,E> list= new Hashtable<E,E>()            
	-------------------+------------------------------------------------------+-----------------------------------------------------	
	객체요소의 개수    |      size()			   		  |                    size() 
	-------------------+------------------------------------------------------+------------------------------------------------------	                       
	객체 저장          |      add()                                           |             put(E key,E value)                                         
     	 -------------------+------------------------------------------------------+-----------------------------------------------------                                                              
	객체 꺼내오기      |     Iterator  iterator(), Enumeration<E> elements()  |            Iterator<K>  iterator() Enumeration<K> keys() 
                           |      ,get(int index)                                 |             get(Object key)     
	-------------------+------------------------------------------------------+-----------------------------------------------------------
	객체 삭제          |    removeAll(Collection<?> c) ,remove(Object o)      |             remove(Object key) 
                           |    ,remove(int index)                                |
	---------------------------------------------------------------------------------------------------------------------------------


	*Iterator 인터페이스 와 Enumeration인터페이스의 주요 메소드
		
		-Iterator
			boolean hasNext():저장된 객체가 있으면 true
			E next():객체를 얻어 낸다.
			remove():객체 삭제

			예]
			Iterator element = 컬렉션객체.iterator();
			while(element.hasNext()){
				System.out.println(element.next());

			}
	
		-Enumeration
			boolean hasMoreElements():저장된 객체가 있으면 true
			E nextElement():객체를 얻어 낸다.


	소스 예]

			-List계열

			//ArrayList<String> list = new ArrayList<String>();
			Vector<String> list = new Vector<String>();

			for(int i = 0;i< 10;i++){

				list.add("List"+i);

			}

			System.out.println("저장된 객체 수"+list.size());

			////////////////
			System.out.println("Iterator 이용");
			Iterator it = list.iterator();

			while(it.hasNext()){

				System.out.println(it.next());

			}
			//삭제
			list.remove(1);
			list.remove("List2");
			System.out.println("for 이용");

			for(int i=0;i<list.size();i++){
			
				System.out.println(list.get(i));

			}

			//Enumeration이용-ArrayList에는 없음
			System.out.println("Enumeration이용");
			Enumeration e = list.elements();

			while(e.hasMoreElements()){

					System.out.println(e.nextElement());

			}

			-MAP계열

			Hashtable<String,Integer> list = new Hashtable<String,Integer>();

			for(int i = 0;i< 10;i++){

				list.put("List"+i,i);

			}

			System.out.println("저장된 객체 수"+list.size());

			////////////////
			System.out.println("Iterator 이용");

			String key,value;

			Set<String> st= list.keySet();
			
			Iterator<String> it = st.iterator();

			
			while(it.hasNext()){
				
				//키값 얻기
				key=it.next();
				value=String.valueOf(list.get(key));
				System.out.println("key값: "+ key +" value값:"+value);

			}
		
			//삭제			
			list.remove("List2");		
			

			//Enumeration이용
			System.out.println("Enumeration이용");
			Enumeration e = list.keys();

			while(e.hasMoreElements()){
					
					key=(String)e.nextElement();
					value=String.valueOf(list.get(key));
					System.out.println("key값: "+ key +" value값:"+value);

			}	
			
			
	

[추상클래스 (Abstract Class)]
   
   - 한 개 이상의 추상 메소드를 가진다면 
     추상 클래스로 선언 해야 함
   - 추상 메소드를 갖고 있지 않더라도 인스턴스 생성을 
      못하게 할 목적이면 추상 클래스로 선언 할 수도 있음
       (추상 메소드가 없어도) 
   - 추상메소드(abstract method)란?
      메소드 몸체(body)없이 선언만 하는 것 
      이 때 메소드 앞에 abstract 란 modifier를 붙여 준다.
		ex) abstract public void abstractMethod();
   - 추상메소드를 한개라도 가진 클래스는 class 앞에    
     abstract를 붙여주어 추상 클래스로 만들어야 한다.

   - 추상 클래스를 상속받은 클래스에서는  
     추상 메소드를 강제적으로 오버라이딩해야한다. 
     그렇지 않을 경우 그 자식 클래스도 추상 클래스가 되어야 함.

   - 추상 클래스는 타입선언은 할 수 있으나  
      new 해서 객체 생성은 할 수 없다.
     즉 상속관계시 부모타입으로 선언하고 
      자식타입의 객체를 생성 할 수는 있다.



	[클래스별 멤버제한]
	----------------------------------------------------------------
	일반 클래스	     |추상 클래스의     | 인터페이스
	(concrete class)     |(abstract class)  | (interface)
	---------------------+------------------+------------------------
	1. 멤버변수	     |  1 +2 +3 +4와    |    1.final변수와
	2. 멤버메소드	     |  추상메소드      | 2.추상메소드만을 멤버로 가짐
	3. 생성자	     |                  |
	4. final변수(상수)등 |                  |
	---------------------+------------------+------------------------

	[final 지정자(modifier)]

	*final지정자가 변수에 지정되면 상수가 됨

	------------------------------------------------------------------------
	         |   abstract	           |  final
	------+------------------+----------------------------------------------
	클래스| 상속이 목적         | 상속을 못받게함
	------+------------------+----------------------------------------------
	메소드|강제로 오버라이딩 | 오버라이딩을 못하게 하기 위함
	         | 시키려는 목적      |
	------+------------------+----------------------------------------------
	변수   |    X                    | 값을 재 할당 못하게 즉 상수로 지정됨(public static을 함께 사용)
	------+------------------+------------------------------------------------
	*abstract 와 final 지정자는 동시에 사용불가(둘 중의 하나만 붙여한다)


[인터페이스 (interface)]

  - 클래스가 객체의 설계도라면 인터페이스는 클래스의 설계도라 할 수 있다
  - 멤버로는 추상메소드와 상수(final변수)로만 구성된다.
  - 접근지정자는 public과 default접근지정만 가질 수 잇다
    modifier(static,final)는 가질 수 없다.
  - 인터페이스에 있는 추상메소드는 public과 abstract란 키워드를 생략한다.
    자식의 오버라딩 메서드에서는 반드시 public을 붙여야 한다.(기본 접근지정자가 아니다)
  - 인터페이스의 변수 또한 public static final을 생략해도, 컴파일러가 자동으로 붙여준다.
	public interface MyInterface{
			  int MONEY=100;// public static final이 생략됨,자동으로 컴파일러가 붙여줌
			  void func(); //추상메소드:public과 abstract를 생략해도 자동으로 붙는다.
	 }

   - 클래스가 인터페이스를 상속받을 때는 implements 란 키워드를 사용한다.
	class GeneralClass implements MyInterface
	{
		//인터페이스를 상속받으면 반드시 
		//추상메소드를 오버라이딩 해야 한다.
		public void func(){
			
		}
		
	}
	    
  - 인터페이스로 인해 다중 상속이 가능하다
 
	class Generclass extends Generalclass2 implements MyInterface,Myinterface2{

		//모든 추상 메소드 오버라이딩

	}


 
 
  - 인터페이스가 인터페이스를 상속받을 때는 extends라는 키워드를 사용하며, 이 때 extends 로 
    여러 개의 인터페이스를 상속받는 것이 가능하다.
	  예]
	  interface MyInter3 extends MyInter1, MyInter2{
			void func();
	   }


 - 인터페이스도 타입 선언은 할 수 있으나, new 해서 객체 생성은 할 수 없다.
   반드시 그 인터페이스를 상속받은 자식 클래스 객체로 생성해야 한다.




[Exception (예외)]

	
	1] 예외(Exception) :프로그램이 실행되는  과정에서 만나게 되는 오류

	2] 예외의 종류

		1.Checked Exception(컴파일 에러)
		 -컴파일러가 판단 할 수 있는 예외. 즉 실행전에 체크 할 수 있는 예외
		 -컴파일 하기 위해서는 반드시 예외 처리 해야 함(Syntax오류,IOException등)
	              -main에서 던져도 됨 즉 직접try~catch로 처리하지 않고..

		2.Unchecked Exception(런타임 에러)
		  -컴파일러가 판단 할 수 없는 예외.즉 실행시에만 발견되는 에러
		  -JVM이 자동으로 예외를 throws 해 줌으로 예외처리를 하지 않도 된다
		  -RuntimeException게열(NullPointerException,ArithmeticException,ArrayIndexOutOfBoundsException등)
		  -반드시 try catch해야함

		3. Error:치명적 에러로 발생 되더라도 적절한 처리를 할 수 없음
		          Error도 역시 Unchecked Exception에 속함(VirtualMachineError:자바가상머신에러)
		         
	3] 예외 처리 목적
	   프로그램 실행시 발생할 수 있는 상황들을 미리정해놓고, 해당하는 예외가 발생했을 경우
	   적절한 조치를 취해서 프로그램이 정상적으로  작동하도록 하기 위함.

	   예외 처리를 한다는 것은 런타임에러를 잡는 다는 것임.

  
	4] 예외 처리 방법

		1. try~catch문을 이용한 직접 처리: 구체적인 예외 처리 가능
	                try
			{
				예외 발생할 만한  코드
			}
			catch (해당예외클래스  e)
			{
				예외 처리 코드
			}
			*하나의 메소드에서 두개 이상의 Exception이 발생할 경우 
			catch절을 여러 개 사용할 수 있다.
			이 때 catch 절로 Exception을 잡을 때는 
			하위클래스(자식클래스)부터 잡아준다.

			예]숫자 입력 받아서 나누는 경우
			   NumberFormatException  ArithmeticException ..< Excption 
			   NumberFormatException 와 ArithmeticException는 상속관계가 아님으로 위치에는 상관없으나
			   Excepion은 모든 예외 클래스의 부모 임으로 항상 다른 예외 클래스 보다 마지막 catch절에서
			   잡아야 한다

		2. throws 절을 이용한 예외 선언:예외 처리를 직접 하지 않고 메소드를 호출하는 쪽으로 떠 넘긴다

			public void func() 
				throws IOException{
					int number=System.in.read();
			}
			
			*func()를 호출하는 쪽으로 IOException 을 넘겨준다.


	
		소스 예]
		public static void exFunc() throws Exception {

		
			out.println("예외를 던지는 메서드");			
			throw new Exception("예외 받아라");
			//예외를 던지는데 받을 곳을 지정 안 한 경우(throws 생략) 에러,
                          throws로 던지던지 자기 자신이 try ~catch로 받던지
			//throw한것은 반드시 어느 한곳에서 try~catch 해야 함 
			    계속 던지기만 하면 안됨
                          //메인에서 최종적으로라도 try~catch 해야 함

			단,throw new ~throws 쌍이 아니라 throws한것은 메인에서도 던질 수 있음
		        또한 Checked 예외는 main에서 던질 수 잇으나 런타임 예외는 메인에서 던져도 예외가 발생
                                                           
		}


		public static void exCatch() throws Exception{//여기서도 예외를 처리 안하고 다시 던짐


			exFunc();		
		}


		public static void main(String[] args) {		

			out.println("프로그램 시작");
			try{
				exCatch();//메인에서 예외 처리
			}
			catch(Exception e){

				out.println(e.getMessage());
			}
			out.println("프로그램 끝");
		}
	       
		
	
	5] finally 절
	
	   try~catch~finally구문의로 사용하고 예외를 잡거나 
	   예외가 발생하지 않다라도 반드시 한번은 수행되는  블럭이다.
	   심지어 return 문이 오더라도 finally블럭은   반드시 실행된다. 
	   단 System.exit(0)의 경우 실행되지 않고 종료된다.

  
   
	6] 사용자 정의 예외 클래스
		
	   -사용자가  Exception클래스를 상속받아 사용자만의 예외를 만들 수 있다

	   step1] Exception을 상속받는 클래스를 만든다.
	   step2]생성자를 구성하고, 생성자 안에서 super("예외 메시지");를 호출한다.
	         이 예외 메시지가 getMessage()를 호출할 때 반환되는 메시지가 된다.


	예제]	(1)사용자 정의 클래스 생성

		class NotManException extends Exception
		{
			//생성자를 구성해서 예외 메시지를 전달
			public NotManException(){
				super("여성 전용 클럽입니다!");
			}
			//생성자 오버로딩
			public NotManException(String msg){

				super(msg);
			}
		}
		
		(2)사용자 정의 클래스 사용
		
		class WonmanClub
		
		{
			 public void Member(String ssn)	 throws NotManException{//메소드 내부에서 Exceptiondl던져 지고 있다는 의미

				 String tmpStr= ssn.substring(6,7);

				 int femaleOrMale = Integer.parseInt(tmpStr);

				 if(femaleOrMale==1){
					// throw new NotManException();//생성한 예외를 Member메소드를 호출한 곳으로 던짐
                                       // 혹은 오버라이딩한 생성자 호출(예외메시지와 함께)
   
					throw new NotManException("여장 한사람도 안되요!");
				 }
				 System.out.println("가입을 환영합니다");
			 }

		
		 }

		(3)적용
		class UserException{

			public static void main(String[] args) {		

			WonmanClub wc = new WonmanClub();
			try{
				wc.Member("1234562111111");
			}
			catch(NotManException e){

				out.println(e.getMessage());
			}
		}

	 *사용자 예외 클래스 객체를 생성해서 throw 라는 키워드로 던져주고, 반드시 메소드 헤더부분에 해당 예외를
	 throws 해줘야 한다.throws를 던져주지 않으면 반드시 에외를 던지는 메소드안에서 try ~ catch로 예외 처리를 해줘야 함





[내부클래스(Inner Class)]



	1]내부 클래스란
	-클래스안의 클래스를 내부 클래스 혹은 Inner클래스 혹은 중첩 클래스,
	Nested클래스라 한다.
	-내부 클래스는 외부 클래스의 변수이나 
	 메서드를 자신의 것처럼 자유롭게 사용가능
	 단,내부 정적 클래스만이 외부의 non-static멤버를 사용 못함
	-내부 정적 클래스만 제외하고 모든 내부클래스가 
	 정적 멤버를 가질 수 없다.
	-GUI에서 이벤트 처리 할때 주로 사용한다
	(내부 클래스 중에서도 주로 내부 무명클래스를 사용)

    ※외부클래스를 인스턴스화(객체화 즉 new)하면
       외부클래스가 heap영역에 메모리가 생기고
       내부클래스는 new해줘야 메모리에 생긴다.
       고로 내부 클래스에서는 외부 클래스가 먼저 메모리에 생김으로
       외부클래스의 모든 멤버를 사용할 수 있다.
       단, 외부클래스에서는 내부클래스의 멤버를 사용하려면
       new(내부 클래스도 설계도임으로)해서 사용해야 한다.(원칙)
       단,내부정적 클래스는 외부 클래스보다 먼저 메모리에 생긴다.

	2]내부 클래스의 종류

		클래스가 정의되는 위치에 따른 분류]
		
		-클래스안에 정의된 클래스

		  1.내부 멤버 클래스(static이 안붙음)
		  2.내부 정적 클래스(static이 붙음)

		-메소드 안에 정의 된 클래스
		
		  3.내부 로컬 클래스(이름이 있는 클래스)
		  4.내부 무명 클래스(이름이 없는 클래스,무명 클래스)
				





	2-1] 내부 멤버 클래스(not-static클래스)

		-static 멤버를 가질 수 없다	
                - GUI에서 이벤트 처리 할때 주로 사용한다	
		-객체 생성
		 외부 클래스의 객체를 먼저 생성후 그 외부객체로 내부 객체를 생성한다
      
		 Outer ot = new Outer();
		 Outer.Inner in = ot.new Inner()

		 -클래스 생성시 클래스 파일이름은 Outer$Inner.class가 된다.


		예]
		class Outer{

			class Inner{

			}
		}


	2-2]내부 정적 클래스

		- 원래 클래스 앞에는 지정자 static이 못 붙지만 클래스안의 클래스는 가능하다 
		  이를 내부 정적 클래스라 한다
		- static멤버를 가질 수 있다
		- 그러나 외부의 instance형 즉 non-static멤버에는 접근 불가

		-객체 생성
                 정적 클래스 이기때문에 외부 클래스 이름으로 생성한다 
		 즉 외부클래스를 먼저 생성할 필요가 없다

		Outer1.Inner1 in = new Outer1.Inner1();

		-클래스 생성시 클래스 파일이름은 Outer1$Inner1.class가 된다.

		예]
		class Outer1{

			static class Inner1{

			}
		}

	
	2-3]내부 익명 클래스
	
		- 이름이 없는 클래스다
		- 상위 클래스를 상속 받아서 오버라이딩 할 경우 주로 사용한다
		- GUI에서 이벤트 처리 할때 주로 사용한다
		- 클래스 생성시 클래스 파일이름은 Outer4$인덱스숫자.class
		- 생성방법

		 class Outer4{		
			
			public void printA(){

				System.out.println("A출력");
			}
			

		 }


		- main메소드에서 Outer4생성시
			
		 아래 {}안에 클래스 멤버 구성하듯이 멤버를 구성한다 주로 상위클래스의 메서드 오버라이딩
		 여기서는 Outer4가 상위 클래스가 됨.
		 Outer4 ot = new Outer4(){
			
		 
		 };

		 예]
			Outer4 ot = new Outer4(){  //부모객체타입 선언하고 자식개채(무명 클래스)로 생성

				public void printA(){

					System.out.println("오버라이딩");
				}
				public void printNew(){

					System.out.println("새로 추가된 메서드");
				}


			};

			ot.printA();//오버라이딩 출력
			ot.printNew();//찾을 수 없다는 컴파일 에러

		 *오버라이딩이 아닌 메서드는 추가해 봐야 사용 못한다 에러발생


		예2]

		interface MyInter
		{
			
			void printNumber();
		}

		public class  Outer5
		{
			public static void main(String[] args) 
			{
		
				//인터 페이스 인스턴스화 가 아니라 무명 클래스 즉 MyInter를 implements하는 무명 클래스 생성 하는 것임
				//원래는 new 자식클래스명 implements MyInter이나 이름이 없기때문에 new MyInter()로 표현
				MyInter mi=new MyInter(){
					public void printNumber(){
						System.out.println("익명 클래스");
					}
				};
			mi.printNumber();
			}
		}

		 
[스레드]

	1]스레드란
	
	  -하나의 프로세스 안에서 실행되는 명령 흐름 즉 프로세스 안의 작은 프로그램이다
	    메서드로 보면 됨.
	  -자바는 멀티 스레딩을 지원하는데 이를 지원하기 위해 Thread클래스와
	    Runnable인터페이스를 제공한다

	  멀티스레딩 이란?
		- 하나의 프로세스 안에서 여러 개의 스레드가 동시 작업하는 것.
		  즉 한 프로그램 내에서 두가지
		  이상의 일을 수행하는 것
		- main메서드(프로그램 진입점)를 가진 자바 프로그램은 
		  하나의 스레드를 가진(main스레드) 단일 스레드라고 
		  볼 수 있다.
		  Thread클래스나 runnable인터페이스를 상속받아 다른 스레드를 
		  동작 시킬 수 있다.

	2] 스레드를 만드는 방법

		-java.lang.Thread 클래스를 상속받아 구현
		-java.lang.Runnable 인터페이스를 상속받아 구현

	
	
		(1) Thread를 상속받아 멀티 스레딩 구현		
			

			-내가 만든 스레드 클래스 정의
			
			class MyThread extends Thread//Thread클래스 상속 받기
			{
				public void run(){//run()메소드 오버라이딩
				
					//스레드가 할 일을 구성(오랜 시간이 걸래는 작업)		
				}
			}

			- 스레드 클래스 사용

			MyThread tr=new MyThread();
			tr.start();//start()를 호출함으로써 MyThread가 실행된다.
     
		(2) Runnable을 상속받아 멀티 스레딩 구현
		

			-내가 만든 스레드 클래스 정의
			
			class MyThread implements Runnable//Runnable인터페이스 상속 받기
			{
				public void run(){//run()메소드 오버라이딩
				
					//스레드가 할 일을 구성	(오랜 시간이 걸래는 작업)			
				}
			}

			- 스레드 클래스 사용

			MyThread tr=new MyThread();
		

			Thread th = new Thread(tr,"스레드명");
			th.start();//start()를 호출함으로써 MyThread가 실행된다.



	3] Thread의 주요 메소드

		- start() : 스레드가 수행을 시작하도록 한다.이때 자바가상머신은 
		  이 스레드의 run()메서드를 호출한다
	        - static int activeCount(): 현재 활성화된 스레드의 수를 리턴한다
	        - static Thread currentThread():현재 실행중인 스레드를 리턴한다
	        - setName(String name): 스레드의 이름을 주어진 이름으로 설정한다
		- String getName():스레드의 이름을 리턴한다
		- sleep(long millis) : 현재 실행중인 스레드를 밀리초동안 sleep시킨다
		- static yield() : 현재 실행중인 스레드가 점유한 CPU를 내놓도록한다 즉,
		  자기와 우선순위가 같거나 높은 스레드에게 실행기회를 준다. 	
		- setPriority(int priorty):스레드의 우선순위를 설정한다
		- int getPriority(): 스레드의 우선 순위를 반환 한다		
		
	
		- join():스레드가 종료 될때 까지 기다린다. 
		       데몬 스레드의 강제 종료를 막기 위해 join()메서드를 호출하면
		       메인 스레드가 종료되어도 데몬 스레드가 완료되어야 종료 된다
		- wait():현재 스레드를 대기 상태로 만든다.
		- notify():wait()로 대기 상태가 된 스레드를 다시 runnable상태로 만든다.

	4] Thread 의 주요 상수
	    : 스레드에 할당 할 수 있는 우선권의 종류
		
		1. static final int MAX_PRIORITY :최대 우선권
		2. static final int MIN_PRIORITY : 최소 우선권
		3. static final int NORM_PRIORITY: 보통 우선권


		setPriority()메서드로  우선권을 설정하고 getPriority()메서드로 
		        현재 스레드의 우선권을 얻어 온다


	5] 동기화(synchronized)

	   - 공유 메모리를 여러 스레드가 동시에 사용하지 못하도록 하는 것(lock을 건다)
             즉 하나의 스레드만이 공유 메모리를 참조 할 수 있도록 제한 하는 방법
	
	   - synchronized 는 메소드에 사용이 가능한 modifier로서, 여러 스레드에 
	     의해 특정 객체의 메소드들이
	     동시 호출되는 것에 대해 잠금(lock)을 설정하여,거부하도록 하는 기능을 지원한다.
	     즉 코드의 한부분, 또는 동기화된 메소드가 다른 스레드와 동시에 수행될 
	     수 없게 하는 것


	6] 동기화 방법

		1.synchronized 블럭을 이용

			public void withdraw(int money){
				
				synchronized(this){
					동기화 블럭

				}
			}

		예]
		class Share
{
	
	int num=10;	
	
}





public class Test{


	public static void main(String[] args) {
			
			Share s = new Share();
			System.out.println("프로그램 시작");
			Func1 th1 = new Func1("첫번째 스레드",s);
			Func2 th2 = new Func2("두번째 스레드",s);
			
			th1.start();
			th2.start();
		
			System.out.println("프로그램 끝");

	}


}

class Func1 extends Thread
{
	
	Share s;
	
	public Func1(String str,Share s){
		super(str);
		this.s=s;
		
	
	}

	public void increase(){
		
		for(int i=0;i <10; i++){
			synchronized (s){
				s.num+=2;
				System.out.println("쓰레드"+currentThread().getName()+"s.num="+s.num);
			}
		}

	}
	synchronized  public void run(){

		
		
		increase();
		
		
	}
}

class Func2 extends Thread
{
	
	Share s;
	
	public Func2(String str,Share s){
		super(str);
		this.s=s;
		
	
	}

	public void increase(){
		
		for(int i=0;i <10; i++){
		
			synchronized(s){
				s.num+=5;
				System.out.println("쓰레드"+currentThread().getName()+"s.num="+s.num);
			}
		}

	}
	public void run(){

		
		
		increase();
		
		
	}
}

		2. 메소드 앞에 synchronized 지정자 사용

			
			synchronized public void withdraw(int money){
				동기화된 메소드
			}


		예]
		class Share
{

	public synchronized void increase(int num,int inc){

		for(int i=0;i < 10;i++){
			num+=inc;
			System.out.println("쓰레드: "+Thread.currentThread().getName()+"num="+num);
		}
		
		
	}
}

public class Test1{

	
	public static void main(String[] args) {
			
			Share s=new Share();
			System.out.println("프로그램 시작");
			Func1 th1 = new Func1("첫번째 스레드",s,10,2);
			Func1 th2 = new Func1("두번째 스레드",s,10,5);
			
			th1.start();
			th2.start();
		
			System.out.println("프로그램 끝");

	}


}

class Func1 extends Thread
{
	
	Share s;
	int init,inc;
	public Func1(String str,Share s,int init,int inc){
		super(str);
		this.s=s;
		this.init=init;
		this.inc=inc;
		
	
	}

	public void run(){

		
		
		s.increase(init,inc);
		
		
	}
}




